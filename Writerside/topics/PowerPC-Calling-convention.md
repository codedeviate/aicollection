# PowerPC Calling convention

The PowerPC calling convention is a set of rules that dictate how functions receive parameters and return values, how the stack is managed, and how registers are used. This ensures that code generated by different compilers can interoperate.

## Key Points of the PowerPC Calling Convention

1. **Registers**:
    - **General-purpose registers**: R0-R31.
    - **Stack pointer**: R1.
    - **Link register**: LR.
    - **Condition register**: CR.

2. **Parameter Passing**:
    - The first eight integer or pointer arguments are passed in registers R3-R10.
    - Additional arguments are passed on the stack.

3. **Return Values**:
    - The primary return value is placed in R3.
    - If a function returns a structure or a union, the address of the return value is passed as a hidden first parameter.

4. **Stack Management**:
    - The stack must be 16-byte aligned at the point of a function call.
    - The caller is responsible for allocating space for the return address and any arguments that do not fit in registers.

5. **Callee-saved Registers**:
    - Registers R14-R31 must be preserved by the callee.
    - The callee must save and restore these registers if it uses them.

## Example

Here is an example of a simple function in PowerPC assembly that adds two integers:

```nasm
.global add
add:
    add r3, r3, r4  ; R3 = R3 + R4
    blr             ; Return, result is in R3
```

## Explanation (1)

- The function `add` takes two integer arguments in registers `R3` and `R4`.
- It adds the values in `R3` and `R4`, storing the result in `R3`.
- The `blr` instruction returns to the caller, with the result in `R3`.

## Example with Stack Usage

Here is an example of a function that uses the stack to store local variables:

```nasm
.global sum_array
sum_array:
    stwu r1, -32(r1)      ; Create stack frame
    mflr r0               ; Save link register
    stw r0, 36(r1)        ; Store link register
    stw r31, 28(r1)       ; Save callee-saved register
    mr r31, r1            ; Set frame pointer

    li r5, 0              ; Initialize sum to 0
    li r6, 0              ; Initialize index to 0

loop:
    cmpw r6, r4           ; Compare index with array length
    bge end_loop          ; If index >= length, exit loop

    lwzx r7, r3, r6       ; Load array element
    add r5, r5, r7        ; Add to sum
    addi r6, r6, 1        ; Increment index
    b loop                ; Repeat loop

end_loop:
    mr r3, r5             ; Move sum to return register
    lwz r0, 36(r1)        ; Restore link register
    mtlr r0               ; Restore link register
    lwz r31, 28(r1)       ; Restore callee-saved register
    addi r1, r1, 32       ; Deallocate stack frame
    blr                   ; Return
```

## Explanation (2)

- The function `sum_array` takes two arguments: a pointer to an array in `R3` and the array length in `R4`.
- It saves the link register and sets up the stack frame.
- It allocates space for local variables.
- It initializes the sum and index to 0.
- It enters a loop to iterate over the array, loading each element, adding it to the sum, and incrementing the index.
- After the loop, it moves the sum to the return register (`R3`), deallocates the local variables, and restores the link register.
- It returns with the sum in `R3`.

These examples illustrate the basic principles of the PowerPC calling convention, including register usage, parameter passing, and stack management.