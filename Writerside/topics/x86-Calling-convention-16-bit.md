Here is the text modified to describe the **x86 calling convention for 16-bit**:

# x86 Calling Convention 16-bit

The x86 calling convention is a set of rules that dictate how functions receive parameters and return values, how the stack is managed, and how registers are used. This ensures that code generated by different compilers can interoperate.

## Key Points of the x86 Calling Convention (16-bit)

1. **Registers**:
    - **General-purpose registers**: AX, BX, CX, DX, SI, DI, BP, SP.
    - **Stack pointer**: SP.
    - **Base pointer**: BP.

2. **Parameter Passing**:
    - Parameters are passed on the stack in **right-to-left** order.
    - The caller pushes the arguments onto the stack before calling the function.

3. **Return Values**:
    - The primary return value is placed in **AX**.
    - If a function returns a structure or a union, the address of the return value is passed as a hidden first parameter.

4. **Stack Management**:
    - The stack must be 2-byte aligned at the point of a function call.
    - The caller is responsible for cleaning up the stack after the function call (cdecl) or the callee cleans up the stack (stdcall).

5. **Callee-saved Registers**:
    - Registers **BX**, **SI**, **DI**, **BP** must be preserved by the callee.
    - The callee must save and restore these registers if it uses them.

## Example

Here is an example of a simple function in x86 assembly that adds two integers:

```nasm
global add
add:
    mov ax, [sp+2]  ; Load first argument into AX
    add ax, [sp+4]  ; Add second argument to AX
    ret             ; Return, result is in AX
```

## Explanation (1)

- The function `add` takes two integer arguments passed on the stack.
- It loads the first argument from `[sp+2]` into `AX`.
- It adds the second argument from `[sp+4]` to `AX`.
- The `ret` instruction returns to the caller, with the result in `AX`.

## Example with Stack Usage

Here is an example of a function that uses the stack to store local variables:

```nasm
global sum_array
sum_array:
    push bp            ; Save base pointer
    mov bp, sp         ; Set base pointer
    sub sp, 4          ; Allocate space for local variable

    mov word [bp-2], 0 ; Initialize sum to 0
    mov word [bp-4], 0 ; Initialize index to 0

loop:
    mov ax, [bp+4]     ; Load array pointer
    mov cx, [bp-4]     ; Load index
    mov dx, [bp+6]     ; Load array length
    cmp cx, dx         ; Compare index with array length
    jge end_loop       ; If index >= length, exit loop

    mov ax, [ax+cx*2]  ; Load array element
    add [bp-2], ax     ; Add to sum
    inc word [bp-4]    ; Increment index
    jmp loop           ; Repeat loop

end_loop:
    mov ax, [bp-2]     ; Move sum to return register
    mov sp, bp         ; Deallocate local variables
    pop bp             ; Restore base pointer
    ret                ; Return
```

## Explanation (2)

- The function `sum_array` takes two arguments: a pointer to an array and the array length, both passed on the stack.
- It saves the base pointer (`BP`) and sets up the stack frame.
- It allocates space for local variables.
- It initializes the sum and index to 0.
- It enters a loop to iterate over the array, loading each element, adding it to the sum, and incrementing the index.
- After the loop, it moves the sum to the return register (`AX`), deallocates the local variables, and restores the base pointer.
- It returns with the sum in `AX`.

These examples illustrate the basic principles of the **x86 16-bit calling convention**, including register usage, parameter passing, and stack management.